#+title: CRTP
#+language: ru
#+export_file_name: ../md/crtp.md

#+options: toc:nil
#+toc: headlines 6

* Введение
Curiously Recurring Template Pattern (CRTP) — это идиома C++. Первое время вы
можете не понимать, как она устроена. Но посидев некоторое время над кодом, вам
все станет ясно. Ну что же, как говорится, «лучше один раз увидеть, чем сто раз
услышать». Потому не будем долго описывать саму идиому, а сразу перейдем к коду.

CRTP состоит из:
- наследования шаблонного класса;
- использования дочернего класса в качестве параметра шаблона базового
  класса.

В коде это выглядит как-то так:
#+begin_src cpp
template<typename T>
struct Parent {
    // ...
};

struct Child : Parent<Child> {
    // ...
};
#+end_src

Основная идея — это использование дочернего класса в базовом. На самом деле, в
данном случае базовый класс будет является приведенным вниз дочерним классом. А
потому мы можем привести базовый класс к дочернему, используя ~static_cast~:
#+begin_src cpp
template<typename T>
struct Parent {
    void do_something() {
        T& derived = static_cast<T&>(*this);
        // используем derived...
    }
};
#+end_src

Обычно при приведении базового класса к дочернему используется ~dynamic_cast~.
Однако мы не используем его здесь. Дело в том, что ~dynamic_cast~ используется в
том случае, когда вы хотите во время выполнения программы убедиться в
корректности преобразования вверх. Однако в данном случае в этом нет
необходимости: базовый класс спроектирован так, чтобы он был унаследован своим
шаблонным параметром. А потому мы можем использовать ~static_cast~.

* Ошибки при использовании CRTP
** Неверный шаблонный параметр
Может случиться такое, что два класса будут унаследованы от одного и того же
базового CRTP класса. В таком случае использование CRTP может привести к
неопределенному поведению, поскольку базовый CRTP класс будет использовать не
тот класс, который ожидался:
#+begin_src cpp
struct ChildOne : Parent<ChildOne> {
    // ...
};

struct ChildTwo : Parent<ChildOne> {  // ошибка в этой строке кода
    // ...
};
#+end_src

К счастью, этой проблемы можно избежать. Для этого нам нужно добавить приватный
конструктор в базовый класс, а также пометить шаблонный класс как ~friend~:
#+begin_src cpp
template<typename T>
struct Parent {
  public:
    // ...
  private:
    Parent() = default;
    friend T;
};
#+end_src

При конструировании дочернего класса будет вызван конструктор базового класса.
Значит, если класс дочерний класс не объявлен как ~friend~, то он не сможет
вызвать конструктор базового класса. Поскольку именно шаблонный класс мы
помечаем как ~friend~, передав неверный параметр шаблона мы получим ошибку
компиляции.

В примерах мы будем опускать использование приватного конструктора, равно как и
~friend T~. Однако при написании кода вам следует пользоваться этим трюком,
чтобы избежать ошибки, описанной ранее.

** Затенение методов
Другая ошибка, с которой можно столкнуться при использовании CRTP, — это
затенение методов. Это происходит из-за того, что методы не являются
виртуальными. Поэтому следует удостовериться, что у вас отсутствуют методы с
одинаковым наименованием в базовом и дочерних классах.
#+begin_src cpp
class Child : Parent<Child> {
    // ой-ой, этот метод затеняет метод `do_something` из базового класса
    void do_something();
};
#+end_src

* Пример использования
** Использование CRTP
В классах возможно реализовать такие методы, которые могут быть использованы в
множестве других классов. Давайте рассмотрим это на примере класса ~Sensitivity~
(в данном случае — чувствительность функции). Согласно [[https://economic_mathematics.academic.ru/5048/Чувствительность_функции][словарю]]:
#+begin_quote
Чувствительность функции — степень изменения функции при заданном абсолютном или
относительном изменении ее аргументов.
#+end_quote
Не имеет значения, хороши ли вы в математике или не очень. Единственное,
что сейчас важно — это то, что класс ~Sensitivity~ хранит какое-то значение:
#+begin_src cpp
struct Sensitivity {
    double get_value() const;
    void set_value(double value);
    // остальная часть интерфейса...
};
#+end_src

Теперь мы хотим добавить вспомогательные методы, такие как умножение на
константное значение (~scale~), возведение в квадрат (~square~) и получение
противоположного числа (~set_to_opposite~):
#+begin_src cpp
struct Sensitivity {
    double get_value() const;
    void set_value(double value);

    void scale(double multiplicator) {
        set_value(get_value() * multiplicator);
    }
    void square() {
        set_value(get_value() * get_value());
    }
    void set_to_opposite() {
        scale(-1);
    }

    // остальная часть интерфейса...
};
#+end_src

Выглядит неплохо. Однако у такого решения есть недостаток. Что если появится
необходимость создать еще один класс, который также содержит некоторое значение
и должен реализовать такие же методы? В этом случае мы можем воспользоваться
CRTP: просто переместим методы в отдельный класс:
#+begin_src cpp
template<typename T>
struct NumericalFunctions {
    void scale(double multiplicator);
    void square();
    void set_to_opposite();
};

struct Sensitivity : NumericalFunctions<Sensitivity>
{
    double get_value() const;
    void set_value(double value);
    // остальная часть интерфейса...
};
#+end_src

Для реализации этих методов нам нужно использовать методы ~get_value~ и
~set_value~ из класса ~Sensitivity~:
#+begin_src cpp
template<typename T>
struct NumericalFunctions {
    void scale(double multiplicator) {
        T& underlying = static_cast<T&>(*this);
        underlying.set_value(underlying.get_value() * multiplicator);
    }
    void square() {
        T& underlying = static_cast<T&>(*this);
        underlying.set_value(underlying.get_value() * underlying.get_value());
    }
    void set_to_opposite() {
        scale(-1);
    }
};
#+end_src

Теперь эту функциональность можно получить просто унаследовав класс
~NumericalFunctions~.

** Шаблонные функции
У вас мог возникнуть вопрос: почему бы не использовать шаблонные функции?
Например, их реализация выглядела бы как-то так:
#+begin_src cpp
template<typename T>
void scale(T& object, double multiplicator) {
    object.set_value(object.get_value() * multiplicator);
}

template<typename T>
void square(T& object) {
    object.set_value(object.get_value() * object.get_value());
}

template<typename T>
void setToOpposite(T& object) {
    object.scale(object, -1);
}
#+end_src

Есть ли смысл использовать CRTP? Смысл есть, поскольку CRTP, кроме всего
прочего, представляет интерфейс класса. В нашем случае, класс ~Sensitivity~
предоставляет интерфейс класса ~NumericalFunctions~:
#+begin_src cpp
struct Sensitivity : NumericalFunctions<Sensitivity>
{
    double get_value() const;
    void set_value(double value);
    // остальная часть интерфейса...
};
#+end_src

С шаблонными функциями так не получится, поскольку они были бы спрятаны где-то в
~#include~. И даже если вы знаете, где находятся эти шаблонные функции, у вас
нет гарантий, что эти функции будут совместимы с конкретным классом. Например,
функция может ожидать функцию ~get~ или ~get_data~ вместо ~get_value~.

** Отличия от обычных интерфейсов
Хотя и CRTP основано на наследовании, это не то наследование, которое обычно
используется с другими классами.

В основном, дочерний класс концептуально является базовым классом. Обычно идея
состоит в том, чтобы использовать базовый класс и через него вызывать методы
дочернего класса.

В случае CRTP все совсем не так. Во-первых, дочерний класс не выражает тот факт,
что он является базовым классом. Наоборот, он расширяет свой интерфейс,
наследуясь от базового класса, чтобы добавить новую функциональность. Поэтому в
этом случае дочерний класс обычно используется напрямую, без использования
базового класса.

Поэтому базовый класс не является интерфейсом, равно как и дочерний класс не
является его реализацией. Все с точностью наоборот: базовый класс использует
методы дочернего класса (в нашем случае это ~get_value~ и ~set_value~). Другими
словами, *дочерний класс предоставляет интерфейс базовому классу*. Это снова
иллюстрирует тот факт, что CRTP несколько отличается от обычного наследования.

* Статические интерфейсы
Еще один использования CRTP — это создание статических интерфейсов. В этом
случае базовый класс является интерфейсом, а дочерний — его реализацией, как в
обычном полиморфизме. Однако отличие заключается в отсутствие виртуальных
методов, а значит все вызовы функций разрешаются на этапе компиляции.

Давайте рассмотрим следующий код. Пусть базовым CRTP классом будет представлять
~Amount~ (количество) с единственным методом ~get_value~:
#+begin_src cpp
template<typename T>
struct Amount {
    double get_value() const {
        return static_cast<T const&>(*this).get_value();
    }
};
#+end_src

Также пусть будет две реализации этого интерфейса: одна возвращает константу,
другая — значение, которое устанавливается в конструкторе. Эти реализации будут
унаследованы от класса ~Amount~:
#+begin_src cpp
struct Constant42 : Amount<Constant42> {
    double get_value() const {
        return 42;
    }
};

struct Variable : Amount<Variable> {
  public:
    explicit Variable(int value) : value_(value) {}

    double get_value() const {
        return value_;
    }

  private:
    int value_;
};
#+end_src

Теперь давайте создадим функцию, которая принимает количество и выводит его в
стандартный вывод:
#+begin_src cpp
template<typename T>
void print(const Amount<T>& amount) {
    std::cout << amount.getValue() << '\n';
}
#+end_src

Эта функция может быть вызвана с помощью любой из двух реализаций:
#+begin_src cpp
Constant42 c42;
print(c42);
Variable v(43);
print(v);
#+end_src

Запустив программу, вы получите:
#+begin_src
42
43
#+end_src

Обратите внимание, что класс ~Amount~ используется полиморфно, хотя мы не
использовали никаких виртуальных методов. Все потому что такой вызов может быть
разрешен на этапе компиляции, а значит нам не нужны виртуальные методы.

Стоит заметить, что CRTP — это не самый лучший способ реализации статических
интерфейсов. Идиома CRTP в этом не так хороша, как концепты, [[https://en.cppreference.com/w/cpp/language/constraints][добавленные в
C++20]]. Все таки CRTP вынуждает наследовать интерфейс, в то время как концепты
лишь определяют требования к типам без привязки к определенному интерфейсу.
Однако идиома CRTP может стать хорошей заменой, если у вас нет возможности
использовать концепты.
