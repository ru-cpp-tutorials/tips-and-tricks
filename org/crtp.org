#+title: CRTP
#+language: ru

#+options: toc:nil
#+toc: headlines 6

* Введение
Curiously Recurring Template Pattern (CRTP) — это идиома C++. Первое время вы
можете не понимать, как она устроена. Но посидев некоторое время над кодом, вам
все станет ясно. Ну что же, как говорится, «лучше один раз увидеть, чем сто раз
услышать». Потому не будем долго описывать саму идиому, а сразу перейдем к коду.

CRTP состоит из:
- наследования шаблонного класса;
- использования дочернего класса в качестве параметра шаблона базового
  класса.

В коде это выглядит как-то так:
#+begin_src cpp
template<typename T>
struct Parent {
    // ...
};

struct Child : Parent<Child> {
    // ...
};
#+end_src

Основная идея — это использование дочернего класса в базовом. На самом деле, в
данном случае базовый класс будет является приведенным вниз дочерним классом. А
потому мы можем привести базовый класс к дочернему, используя ~static_cast~:
#+begin_src cpp
template<typename T>
struct Parent {
    void do_something() {
        T& derived = static_cast<T&>(*this);
        // используем derived...
    }
};
#+end_src

Обычно при приведении базового класса к дочернему используется ~dynamic_cast~.
Однако мы не используем его здесь. Дело в том, что ~dynamic_cast~ используется в
том случае, когда вы хотите во время выполнения программы убедиться в
корректности преобразования вверх. Однако в данном случае в этом нет
необходимости: базовый класс спроектирован так, чтобы он был унаследован своим
шаблонным параметром. А потому мы можем использовать ~static_cast~.

* Ошибки при использовании CRTP
** Неверный шаблонный параметр
Может случиться такое, что два класса будут унаследованы от одного и того же
базового CRTP класса. В таком случае использование CRTP может привести к
неопределенному поведению, поскольку базовый CRTP класс будет использовать не
тот класс, который ожидался:
#+begin_src cpp
struct ChildOne : Parent<ChildOne> {
    // ...
};

struct ChildTwo : Parent<ChildOne> {  // ошибка в этой строке кода
    // ...
};
#+end_src

К счастью, этой проблемы можно избежать. Для этого нам нужно добавить приватный
конструктор в базовый класс, а также пометить шаблонный класс как ~friend~:
#+begin_src cpp
template<typename T>
struct Parent {
  public:
    // ...
  private:
    Parent() = default;
    friend T;
};
#+end_src

При конструировании дочернего класса будет вызван конструктор базового класса.
Значит, если класс дочерний класс не объявлен как ~friend~, то он не сможет
вызвать конструктор базового класса. Поскольку именно шаблонный класс мы
помечаем как ~friend~, передав неверный параметр шаблона мы получим ошибку
компиляции.

** Затенение методов
Другая ошибка, с которой можно столкнуться при использовании CRTP, — это
затенение методов. Это происходит из-за того, что методы не являются
виртуальными. Поэтому следует удостовериться, что у вас отсутствуют методы с
одинаковым наименованием в базовом и дочерних классах.
#+begin_src cpp
class Child : Parent<Child> {
    // ой-ой, этот метод затеняет метод `do_something` из базового класса
    void do_something();
};
#+end_src
